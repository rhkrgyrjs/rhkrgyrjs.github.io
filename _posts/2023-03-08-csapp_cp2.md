---
title: "[CSAPP] 챕터2 정리"
excerpt: "정보의 표현과 처리"

categories:
  - CSAPP
tags:
  - [computer_architecture]

permalink: /CSAPP/csapp_cp2/

toc: true
toc_sticky: true

date: 2023-03-08
last_modified_at: 2023-03-08
---


## Cp2 : 정보의 표현과 처리

## 컴퓨터가 정보를 처리하는 방식

+ 컴퓨터 시스템에서 정보를 저장하는 방식은 사람에겐 직관적이지 않고, 이해하기 힘든 오류를 일으킬 수 있다.

+ 컴퓨터는 이진수 바이트 단위로 정보를 저장하고 표현한다. 
    + 메모리에 접근하려면 바이트 단위로 정보를 처리하는 것이 편하기 때문이다. 메모리는 바이트 단위로 주소지정이 가능하다.
    + 이진수 표기는 장황하기 떄문에, 4자리의 이진수와 1대1 대응이 되는 16진수를 사용한다. 16진수 두 자리로 1바이트의 정보를 표현하는 것이 유용하기 때문이다.

아래는 0~15까지의 10진수 - 2진수 - 16진수 표기를 나타낸 표이다.

| Dec | Bin | Hex |
|:----:|:----:|:----:|
| 0 | 0000 | 0x0 |
| 1 | 0001 | 0x1 |
| 2 | 0010 | 0x2 |
| 3 | 0011 | 0x3 |
| 4 | 0100 | 0x4 |
| 5 | 0101 | 0x5 |
| 6 | 0110 | 0x6 |
| 7 | 0111 | 0x7 |
| 8 | 1000 | 0x8 |
| 9 | 1001 | 0x9 |
| 10 | 1010 | 0xA |
| 11 | 1011 | 0xB |
| 12 | 1100 | 0xC |
| 13 | 1101 | 0xD |
| 14 | 1110 | 0xE |
| 15 | 1111 | 0xF |

+ C에서는 접두사 0x 를 붙여 16진수를 표기한다.

+ 가상 주소공간은 프로그램에게 제공되는 개념적인 이미지일 뿐이다. (추상화이다.)

+ 모든 컴퓨터는 word size라는 포인터의 정규 크기를 가진다.
    + word size가 w인 컴퓨터의 메모리 주소 지정은 0 ~ 2^w-1 의 범위에서 이루어진다.
    + 32bit 시스템에서 램을 4GB 이상 사용하지 못하는 이유이다.
    + 대부분의 64bit 시스템은 32bit와의 호환성을 가지고 있다.
    + 프로그램을 컴파일 할 때 프로그램의 word size 지정이 가능하다.

---

## 정보의 저장

+ 컴퓨터는 이진 방식으로 정보를 저장하며, 0과 1을 해석(디코딩)하는 방식에 따라 의미가 부여되는 것이다. 
    + 만약 4바이트 크기를 가지는 데이터 타입 변수에 값 0x00000041 이 저장되어 있다면 ASCII 방식에 따라 해당 변수를 해석하면 'A'라는 문자, 비부호형 정수의 방식으로 해석한다면 정수 65의 값을 가지게 된다.
    + 데이터 타입과 무관한 해석을 할 수도 있으며, 이런 방식은 종종 사용된다. (char 타입을 비부호형 정수 방식으로 해석하는 등)

+ int32_t와 같은 자료형들은 환경에 무관하게 같은 크기의 자료형을 제공한다.
    + 32bit -> 64bit 시스템으로의 전환이 이루어지던 시기에 word size 의존성 문제가 대두된 적이 있다. 32bit 시스템에서는 4바이트 자료형이 포인터 주소를 저장할 수 있었지만, 64bit 시스템에서는 그렇지 않기 때문이다.

+ 컴퓨터는 객체의 바이트를 메모리상의 연속된 주소애 저장한다.
    + 해당 객체의 주소는 사용된 메모리의 첫 번째 바이트의 주소이다.

+ 바이트를 정렬(저장)하는 방식에는 두 가지 관습이 있다.
    + big-endian : most signigicant bit 부터 저장하는 방식.
    + little-endian : most significant bit 를 가장 나중에 저장하는 방식.
        + most significant bit : 맨 앞 비트를 말한다. 보통 맨 앞의 비트가 가장 유의미한 가중치를 가진다.
        + 컴퓨터 사이 통신하는 과정에서 두 방식의 차이가 문제를 일으킬 수 있다. 따라서 통신 과정에서 정보를 변환하는 과정을 거친다.
        + 대부분의 intel 호환 머신은 little-endian 방식을 사용한다.

+ 정수와 부동소수점의 인코딩 방식에는 차이가 있지만, 부분적으로 일치하는 비트 패턴을 가진다. (각각의 인코딩 방법은 아래서 설명한다.)

+ C에서는 문자열을 null 문자(0x00)로 종료되는 문자의 배열로 인코딩한다.

+ 같은 코드를 컴파일하더라도 생성되는 기계어는 환경에 따라 다르며, 바이너리 호환성을 가지기에는 어렵다.

---

## Boolean 대수, 비트수준 연산

{0,1} 의 집합에 대해 정의되며, C에서의 비트수준 연산과 관련이 있다. 

+ 두 비트간의 연산이 아니라, 길이가 같은 두 비트 벡터 사이에도 대응되는 비트들간 연속적으로 부울 연산을 적용해 새로운 비트 벡터를 생성할 수 있다.

+ 비트 벡터를 사용해 집합을 인코딩하는 것은 자주 쓰이는 기법이다. (예) RGB 인코딩)

+ 비트수준 연산은 일반적으로 마스크 연산을 할 때 주로 사용된다.
    + 마스크 연산 : 특정한 마스크 비트 벡터를 활용해 주어진 비트 벡터중 의미있는 비트를 추출해 내는 연산이다.

+ C에서 논리 연산과 비트 연산의 차이가 있다.
    + 논리 연산은 0을 false, 0이 아닌 값을 true로 간주한다.
    + 논리 연산은 수식의 결과가 첫 인자를 계산했을 때 정해지면 나머지 연산은 수행하지 않는다.

+ shift 연산 : 비트 패턴을 좌우로 이동시킨다.
    + 좌측으로 이동하는 경우 : 밀려난 비트는 삭제, 우측의 빈자리는 0으로 채운다.
    + 우측으로 이동하는 경우
        + logical shift : 좌측의 빈자리 0으로 채움 (비부호형 인코딩된 정수의 값 보존)
        + arithmetic shift : 좌측의 빈자리 most significant bit 복사해서 채움 (부호형 정수의 인코딩된 값 보존)
    + C에 어떤 우측 쉬프트를 사용해야 한다에 대한 표준은 없지만, 값을 보존하는 쪽으로 지원하는 것이 보통이다. (비부호형은 logical, 부호형은 arithmetic)
    + Java는 logical shift와 arithmetic shift를 다른 연산으로 보고, 다른 operator를 사용한다.
    + 정보를 이진수 방식으로 처리하는 컴퓨터의 특성상 쉬프트 연산은 2의 거듭제곱으로 표현 가능한 수의 곱셈이나 나눗셈을 대체할 수 있다. (쉬프트 연산은 정수의 곱셈이나 나눗셈보다 더 적은 사이클을 필요로 함. 컴파일러가 최적화에 이용되는 기법임)

진리표 작성이나 각 연산의 operator(특수기호) 정리는 따로 하지 않겠다.

---

## 정수

### 1. 비부호형 정수 (unsigned)

일반적인 2진수 변환 방식을 따르며, 수식으로 나타내면 아래와 같다.

![unsigned_encoding](/assets/images/csapp/unsigned_encoding.png)

### 2. 부호형 정수 (singed)

2의 보수 방식 인코딩을 활용한다.  
비트 벡터 x의 길이가 w일 때, most significant bit에 -(2^(w-1))의 가중치를 둔다.  
most significant bit를 제외한 나머지 부분에는 비부호형과 동일한 인코딩 방식을 적용한다. 수식으로 나타내면 아래와 같다.

![signed_encoding](/assets/images/csapp/signed_encoding)

 + 부호형의 경우 표현 가능한 양수-음수 의 수가 대칭적이지 않은데, 0을 인코딩하는 경우가 most significant bit가 0일 경우에 포함되기 때문이다. 따라서 부호형으로 표현 가능한 양수의 갯수 = 표현 가능한 음수의 갯수 -1 이다.


### 3. 부호형 - 비부호형 간의 형변환

부호형 - 비부호형 간의 형변환은 디코딩 방법만 다르게 하면 된다.
값이 두 방식에서 표현 가능한 범위 안에 있을 경우 두 방식간의 디코딩 결과가 같다. 
 + 즉, most significant bit가 0일 경우 디코딩 결과가 같다.

값이 변환 가능한 범위 밖일 경우에는 디코딩 방법만 달리해서 해석한다.

결과적으로 부호형-비부호형 변환시에는 비트 벡터를 수정하지 않으며, 디코딩 방식만 바꾸는 것이다. 

아래는 값이 범위 밖인 경우를 정리한 그림이다.

![unsigned_signed_conv](/assets/images/csapp/unsigned_signed_conv.png)

>내 예상에는, 위와 같은 인코딩 방식을 채택한 이유는 아마 CPU 연산장치 설계상에 있을 것이다.  
부호형 간의 연산과 비부호형 간의 연산이 다른 회로를 이용하면 비효율적이니까.. 연산의 결과값이 표현 가능한 범위 안에 있다면, 하나의 회로로도 두 자료형간의 연산결과가 유효하도록 할 수 있으니 말이다. 결과값이 범위를 벗어난다면 어차피 오버플로니까 말이다.

### 4. 부호형 - 비부호형 간의 비교연산

두 값 모두 비부호형이라고 간주하는 방식을 사용한다.  
(아마 이것도 회로 설계상의 문제일 것이다.)

이때 비직관적인 결과가 발생할 수 있다.

예를 들어, 10000u > -1 의 결과값은 어떻게 될까?  
+ 비부호형 정수의 경우 접미사 u를 붙여 표현한다.  

일반적으로 생각해 본다면 10000은 -1보다 크므로 true가 해당 연산의 결과값일 것이다. 

하지만 위 연산의 결과는 false이다.  
-1이 저장된 변수의 자료형이 signed int (4바이트 자료형)이라고 생각해 보자. 이때 -1의 16진수 표기는 0xFFFFFFFF 이고, 2진수 표기는 0b11111111111111111111111111111111 이며, 이 값을 비부호형 정수의 디코딩 방법으로 해석하면 2^32-1 이라는 값이 나온다. 

계산하면 4294967295u 와 같다. 따라서 4294967295 > 10000 이므로
위 연산의 결과값은 false다.

### 5. 자료형의 확장

+ 자료형의 비트 수를 확장하는 방법에는 두 가지가 있다.
    + zero extention(영의 확장) : 늘어난 자리의 비트를 0으로 채운다.
    + sign extension(부호 확장) : 늘어난 자리의 비트를 most significant bit를 복사해서 채운다.

당연히, 자료형의 크기는 확장하더라도 변수가 저장하고 있는 값은 변하지 않게 유지하는 것이 이상적일 것이다. 

비부호형의 경우 앞에 0을 추가하는 것(zero-extension)만으로 변수의 값을 유지하며 확장이 가능하다.  
기존의 있던 비트들의 가중치는 변하지 않으며, 추가된 비트는 0이기 때문에 기존의 값에 영향을 미치지 않기 때문이다.

비부호형의 경우 most significant bit를 복사해 채워넣는 방식으로 확장(sign-extension)하게 되는데, 이 경우 signed(2의 보수) 방식으로 저장되어 있던 변수의 값이 유지된다는 귀납적인 증명이 가능하다.

![sign_extension_proof](/assets/images/csapp/sign_extension_proof.png)

사용된 주요 성질은 2^w - 2^(w-1) = 2^(w-1) 이다.

### 6. 자료형의 절삭

+ 자료형의 비트 수를 확장하는 것이 가능하다면, 자료형의 비트 수를 절삭(줄이는)하는 것도 가능하다.

+ modulo 연산 : C에서 % 를 operator로 가지는 연산으로, 나눗셈의 나머지를 결과값을로 가지는 연산이다. (mod로 표기한다.)

+ 자료형 크기의 절삭은 단순히 상위 비트를 버리는 방식을 따른다.

비부호형 변수 x가 k비트 수로 절삭할 때  
절삭 후 x' 의 값은
x' = x mod (2^k) 가 된다. (가중치가 2^k이상인 비트는 버려지기 때문이다)

아래는 간단한 절삭의 예이다.

#### 예 1. 5비트 비부호형 변수 x를 4비트로 절삭하는 경우
x = 0b11011 이라면 x의 십진수 값은 16+8+2+1 = 27  
이때 x를 4비트로 절삭(k=4)하면 x = 0b1011  
절삭한 후의 x의 십진수 값은 8+2+1 = 11  
( 27 mod 2^4 = 11 )

#### 예 2. 5비트 부호형 변수 y를 4비트로 절삭하는 경우
y = 0b10011 이라면 y의 십진수 값은 -16+2+1 = -13  
이때 y를 4비트로 절삭하면 y = 0b0011  
절삭한 후의 y의 십진수 값은 2+1 = +3

>y를 비부호형 인코딩으로 해석한다면  
절삭 전 : 16+2+1 = 19  
절삭 후 : 2+1 = 3  
( 19 mod 2^4 = 3 )
 
### 7. 정수의 연산

정수의 연산은 오버플로우 유무만 확인하면 된다.  
연산의 결과값이 자료형이 표현 가능한 범위 안이라면 제대로 계산된 값이 출력될 것이고, 아니라면 오버플로우 된 값이 출력될 것이다.  
비트 수준의 덧셈과 뺄셈 계산결과는 자료형에 상관없이 같고, 넘치는 비트는 버려진다(절삭된다).  
대부분의 컴퓨터는 자료형과 상관없이 동일한 기계어 인스트럭션을 사용한다.

비부호형 w비트 자료형의 두 변수 x, y에 대해 오버플로우 조건과 오버플로우 시 값은 다음과 같다.  
![unsigned_overflow](/assets/images/csapp/unsigned_overflow.png)  
아래 그림은 오버플로 시 값을 도식화한 것이다.  
![unsigned_overflow_image](/assets/images/csapp/unsigned_overflow_image.png)

부호형 w비트 자료형의 두 변수 x, y에 대해 오버플로우 조건과 오버플로우 시 값은 다음과 같다.  
![signed_overflow](/assets/images/csapp/signed_overflow.png)  
아래 그림은 오버플로 시 값을 도식화한 것이다.  
![signed_overflow_image](/assets/images/csapp/signed_overflow_image.png)

곱셈, 나눗셈의 경우도 같다. 계산한 값의 넘치는 비트는 절삭하고 하위 비트만을 취하는 방식으로 작동한다.  
곱셈과 나눗셈은 적절한 쉬프트 연산으로 변환되기도 한다.

## 부동소수점

컴퓨터에서의 부동소수점 표현은 V = x * 2^y 형태의 소수를 인코딩한다.  
위 방법으로 표현되지 않는 수는 근사(rounding)해 표현한다.

현대적인 컴퓨터들은 IEEE 754 표준을 토대로 부동소수점을 표현한다.

IEEE 754 표준은 수를 V = (-1)^S * M * 2^E 의 형태로 나타내고,  
부동 소수점 수의 비트 표시는 각 변수를 인코딩하기 위한 필드로 나누어진다.
+ S : 수가 양수인지 음수인지를 결정한다. 
    + s 필드 : 한 개의 부호 비트로, S를 직접 인코딩한다. (most significant bit이다.)
+ M : 비율 이진수. 숫자의 값을 결정한다.
    + exp 필드 : 유효숫자 M을 인코딩한다.
+ E : 2의 제곱 형태로 숫자의 자리값을 결정한다.
    + exp 필드 : 지수 E를 인코딩한다.

아래 표는 자료형별 필드의 비트 수이다.  
| - | float (single-percision) | double (double-percision) |
|:----:|:----:|:----:|
| s 필드 | 1 | 1 |
| exp 필드 | 8 | 23 |
| frac 필드 | 11 | 52 |

![ieee_754_bit_field](/assets/images/csapp/ieee_754_bit_field.png)

IEEE 754 표준에서는 exp 필드의 비트 배열에 따라 값의 유형이 3가지로 나뉜다.  
+ normalized value(정규화 값) : 일반적인 수 표시
+ denomalized value(비정규화 값) : 0(0에 매우 가까운 값)표시
+ special value(특수 값) : 무한대나 NaN(Not a Number) 등 특수한 경우

![ieee_754_types](/assets/images/csapp/ieee_754_types.png)

### 1. 정규화 값

exp 필드가 모두 0이 아니거나, 모두 1이 아닐 경우 정규화 값이 된다.

가장 일반적인 경우로,  
E = e - Bias 로 인코딩된다.  
+ e : exp 필드의 unsigned 인코딩
    + 단일 정밀도의 경우 -126 ~ + 127, 이중 정밀도의 경우 -1022 ~ +1023 의 범위를 가진다.
+ Bias = 2^(k-1) - 1
    + k : exp 필드의 길이 (비트수)
> **Bias 인코딩을 사용하는 이유**  
Bias 인코딩을 사용하면 가장 작은 exp 는 전부 0으로 나타낼 수 있고,  
가장 큰 exp 는 01111.. 으로 나타낼 수 있다.   
Bias를 활용한 인코딩 방법을 사용하면 부동소수점 수 간 비교할 때 비부호형의 비교와 똑같은 비트수준 연산을 활용할 수 있게 된다.

M = 1 + frac 으로 인코딩  
+ frac : frac은 0.xxxx... 의 이진수 표시를 가진다고 해석된다. (즉 M의 비트 표시는 1ffff... 로 가정된다.)
    + 암시적 선두 1 : 어차피 자릿수는 E에 의해 정해지므로, 자릿수 표기를 위해 선두에 있는 0은 생략하고 맨 앞 비트가 1이라고 가정한다. (공짜 비트를 하나 얻기 위한 꼼수이다.)
    + 암시적 선두 1때문에 M은 항상 1 <= M < 2 의 범위를 가지게 되므로, 0을 표현하기 위한 비정규화 값이 필요하게 된다.

### 2. 비정규화 값

exp 필드가 모두 0일 때 비정규화 값이 된다.

E = 1 - Bias 로 인코딩된다.

M = f 로 인코딩된다. (즉, 암시적 선두 1이 없다.)

비정규화 숫자는 두 가지 목적으로 사용된다.  
1. 0을 표기하기 위해.
    + 암시적 선두 1이 있다면 0을 표현할 수 없다.
    + 0b0000000... 로 +0.0을, 0b1000000... 로 -0.0을 나타낼 수 있다.
1. 0.0에 아주 가까운 값을 나타내기 위해.
    + 점증적 언더플로우 : 0.0 근처에서 표현 가능한 값들은 같은 간격을 가진다.

### 3. 특수 값

exp 필드가 모두 1일 때 특수 값이 된다.

+ frac 필드가 모두 0 : 무한대 (+무한대, -무한대)
    + 무한대는 매우 큰 값의 곱셈, 0으로 나누기 등을 나타낼 수 있음.
+ 비율 필드가 모두 0이 아님 : NaN(Not a Number)
    + 결과값이 실수나 무한대가 아닌 경우 ( sqrt(-1), 무한대-무한대 등 )  

아래 그림은 IEEE 754 표준으로 표현 가능한 값들의 간격을 나타낸 것이다.

![ieee_754_interval](/assets/images/csapp/ieee_754_interval.png)

#### IEEE 754 표준을 따르는 부동소수점 인코딩의 예

float F = 15213.0 일 때

float 자료형의 exp 필드의 비트수는 8비트이므로,  
Bias = 2^(8-1) - 1 = 127

15213 = 0b11101101101101 = 0b0.11101101101101 * 2^13 이다.

이때 M = 1.1101101101101 이고,
frac 필드의 값은 111011011011010000000000 이다.

E = e - Bias = e - 127 = 13 이 되어야 하므로  
e = 140 = 0b10001100, exp 필드의 값은 10001100

양수이므로 s = 0

즉,  
float F = 15213.0 과  
float F = 0b010001100111011011011010000000000 는 같은 표현이다.


### 근사법

IEEE 754 표준에는 4가지 근사 방법이 있다.
+ round-toward-zero : 0 방향으로 근사
+ round-down : 음의 무한대 방향으로 근사
+ round-up : 양의 무한대 방향으로 근사
+ round-to-even : 가까운 짝수로 근사 (기본값)

아래는 각 근사법의 예이다.

![rounding_example](/assets/images/csapp/rounding_example.png)

짝수로 근사하는 방법에는 두 가지 장점이 있다.  
1. 통계적으로 안정된 값을 얻을 수 있다.
    + 비율상 절반은 위쪽으로, 절반은 아래쪽으로 근사하기 때문에 전체적인 평균값이 높거나 낮게 나타날 일이 없다.
1. 근사하는 값이 정수가 아니더라도 사용이 쉽다.
    + 이진 표현의 경우, least significant bit(가장 덜 중요한 비트, 가장 오른쪽 비트)만 고려하면 된다.

### 부동소수점 연산

부동소수점 값 x, y를 실수로 보고, 결과값은 연산된 값의 근사인 round(x @ y) 가 된다. (@는 특정 연산의 operator이다.)

+ 근사를 이유로, 부동소수점 연산에서는 결합법칙이 성립하지 않는다.

---

2장은 내용이 좀 길지만, 전체적으로 흐름이 비슷하다.
