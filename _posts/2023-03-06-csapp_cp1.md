---
title: [CSAPP] 챕터1 정리
excerpt: "컴퓨터 시스템으로의 여행"

categories:
    - CSAPP
tags:
    -[computer_architecture]

permalink: /CSAPP

toc: true
toc_sticky: true

date: 2023-03-06
last_modified_at: 2023-03-06
---

### CSAPP?

![csapp](/assets/images/csapp/csapp_cover.png)

Computer Systems : A Programmer's Perspective

프로그래머 시점에서 쓴 컴퓨터 시스템에 대한 전반적인 내용을 다룬 책이다.  
해외 대학에선 컴퓨터 공학 입문 서적으로 아주아주 유명하다.  
군대 다녀오면서 잊어버린 컴퓨터 공학의 개괄을 다시 잡기 위해 공부해보려고 한다.

---

## Ch1 : 컴퓨터 시스템으로의 여행
챕터 1은 이 책의 전반적인 내용 구성과 주요 단어의 설명이 주를 이룬다.

## 용어와 개념

+ 소스 파일은 비트들의 연속이며, 각각의 문자는 바이트 단위로 저장된다 (ASCII, 혹은 UNICODE). 아래의 이미지는 hello world 예제 소스코드의 글자를 ASCII 코드에 대응시킨 것이다. (줄바꿈도 하나의 문자로 취급한다.)

![helloworld_ascii](/assets/images/csapp/helloworld_ascii.png)

+ 소스를 실행시킬 수 있는 상태로 만들기 위해선 일련의 과정이 필요하다. 그 과정은 다음과 같다.


    1. Pre-processing(전처리) : 소스코드를 컴파일하기 전 필요한 작업을 하는 과정이다. C언어의 경우 # 문자로 시작하는 directive에 따라 소스 코드를 수정한다.
    1. Complie : 전처리 된 소스를 토대로 어셈블리어로 작성된 파일을 생성한다.
    1. Assembly : 어셈블리어로 작성된 코드를 실행 가능한 기계어로 번역해 목적 파일을 생성한다.
    1. Link : 프로그램을 실행하는 데 필요한 다른 코드들(목적 파일들)을 하나로 합쳐 Excutable Object File(실행 가능 목적파일, 메모리에 적재되어 시스템에 의해 실행이 가능한 파일)로 만든다.

![compile_system](/assets/images/csapp/compile_system.png)

+ 컴파일 시스템이 어떻게 동작하는 지 이해하는 것은 매우 중요하다. 
    + 작성한 코드가 어떻게 기계어 문장으로 번역되는지 알아야 성능 최적화를 할 수 있다.
    + 큰 프로젝트에서 각 코드의 의존성에 대해 이해하려면 링크 에러에 대해 이해하고 있어야 한다.
    + 버퍼 오버플로우와 같은 보안 구멍이 생기는 것을 막기 위해서는 신뢰할 수 없는 데이터의 흐름을 알아야 한다.

+ 한 개의 기계어 인스트럭션(어셈블리 명령)은 다양한 바이트 단위의 크기로 표현될 수 있고, 프로그램의 변수들은 데이터 타입에 따라 서로 다른 바이트 단위의 크기를 가진다. 아래의 표는 C언어에 존재하는 변수들의 크기(32bit/64bit 시스템에서의)를 정리한 것이다.

| C declaration | Bytes |
|:-------------:|:-----:|
| char | 1 |
| short | 2 |
| int | 4 |
| long | 시스템의 word 크기 |
| int32_t | 4 |
| int64_t | 8 |
| void * | 시스템의 word 크기 |
| float | 4 |
| double | 8 |

(intXX_t 와 같은 타입은 어느 환경에서나 동일한 XX비트 크기를 보장하는 타입들이다.)

+ 한 개의 기계어 인스트럭션은 내부적으로 여러 단계를 거쳐 실행된다.

+ 버스(bus) : 시스템(컴퓨터) 내 전기적인 배선군을 뜻한다. 구성 요소 간 바이트 단위의 정보를 전송하며, 전송되는 정보의 크기를 word라고 한다. 
    + word는 시스템에서 지정할 수 있는 메모리 주소의 크기를 결정짓는 중요한 요소이다. 32bit 시스템에서 램을 4gb까지밖에 못 쓰는 이유도 4gb 이상의 램의 주소에 접근하는 데 어려움이 있기 때문이다.

+ 메인 메모리 : 프로그램 실행 시 데이터/프로그램 코드가 저장되는 임시 저장장치이다. 물리적으로는 DRAM 칩, 논리적으로는 연속적인 바이트들의 배열로 볼 수 있으며, 바이트 단위로 주소를 지정해 접근이 가능하다.
    + 거대한 바이트들의 배열인 '가상 메모리'라는 추상화를 구현하는 것은 하드웨어-소프트웨어 간의 복잡한 상호작용이다.
  
+ 프로세서 : 메인 메모리에 적재된 인스트럭션들을 실행하는 엔진이다. 프로세서의 중심에는 PC(Program Counter)라는 해당 시스템의 word크기의 레지스터가 존재한다. 어느 한 시점에 PC는 다음에 실행할 인스트럭션의 메모리 주소를 저장하고 있다. (포인터의 개념과 같다.)
    + 프로세서는 적재, 저장, 작업, 점프 등 단순한 작업을 인스트럭션의 요청에 따라 연속적으로 수행할 뿐이다.
        + 적재(load) : 메인 메모리 -> 레지스터로 데이터 덮어쓰기
        + 저장(store) : 레지스터 -> 메인 메모리로 데이터 덮어쓰기
        + 작업(operate) : 두 레지스터의 값을 ALU(Arithmetic and Logic Unit, 산술논리장치)로 복사하고 연산을 수행한 후 덮어쓰기 방식으로 레지스터에 저장
        + 점프 (jump) : 인스트럭션으로부터 한 개의 워드를 추출해 PC에 덮어쓰기 함

+ 입출력 장치 : 시스템과 외부세계를 연결하는 장치. (키보드, 모니터, 마우스, 프린터, 스피커, 마이크...)

아래 그림은 전형적인 시스템의 하드웨어 구성을 나타낸다.

![typical_hardware_system](/assets/images/csapp/typical_hardware_system.png)

---

## hello 프로그램의 실행주기
1. 쉘 프로그램에 ./hello를 입력한다.
    + 이때 쉘 프로그램이 문자들을 레지스터에 읽어들인 후, 메모리에 저장한다.
1. 키보드의 엔터 키를 누르면, 쉘은 파일 내의 코드와 데이터를 복사하는 인스트럭션을 실행한다.
    + 실행파일 hello를 디스크에서 메인 메모리로 적재한다.
    + 이때 DMA(Direct Memory Access, 직접 메모리 접근)라고 알려진 기법을 사용해 데이터가 프로세서를 거치지 않고 디스크에서 메모리로 직접 이동한다.
1. hello가 메모리에 복사되면, 프로세서는 hello 프로그램의 main루틴의 기계어 인스트럭션을 실행하기 시작한다.
    + 이후 hello프로그램의 루틴이 실행되며, 이 과정에서 "hello world/n" 스트링이 메모리에서 레지스터로 복사되고, 디스플레이 장치로 전송된다.

---

## 메모리 계층구조와 캐시
+ 모든 저장 장치는 계층구조를 이룬다. 보통의 경우, 높은 계층에 있다는 말은 가격대비 저장공간이 작고, 빠르며, 프로세서와 가깝다는 뜻이다.

| 특성 | 높은 계층 | 낮은 계층 |
|:---:|:-----:|:-----:|
| 비용 | 높음 | 낮음 |
| 저장공간 | 작음 | 넓음 |
| 속도 | 빠름 | 느림 |
| 프로세서와의 거리 | 가까움 | 멈 |

위 표를 그림으로 표현하면 이렇다.

![memory_hierarchy](/assets/images/csapp/memory_hierarchy.png)

+ 캐시(cache) : 단기간에 필요로 할 가능성이 높은 정보를 임시로 저장하기 위한 저장장치.
    + 프로그램이 실행되는 시간 중 대부분은 정보의 이동에 소요된다. 즉, 계층간 저장장치의 속도 차이 때문에 대부분의 오버헤드가 발생한다는 것이다. 이런 오버헤드를 줄이고자 만들어진 것이 캐시 메모리이다.

+ 메모리 계층구조의 주요 아이디어는 한 레벨의 저장장치가 하위 레벨의 저장장치의 캐시 역할을 수행하는 것이다.

___

## 운영체제
+ 하드웨어를 관리하는 주체는 OS(Operating System, 운영체제)이다. 운영체제의 주요 목적은 두 가지이다.
    1.  프로그램이 하드웨어를 마음대로 사용하는 것을 방지
    1.  균일하고 간단한 방법으로 하드웨어를 조작할 수 있게 하는 것(API 제공)이다.

    + 응용 프로그램이 입출력 장치나 메모리 등의 자원을 이용하는 과정은 운영체제를 통해서(시스템 콜) 이루어진다.

+ 프로세스(processe) : 실행 중인 응용 프로그램에 대한 추상화이다.
    + 운영체제는 문맥 교환(Context Switching)을 통해 다수의 프로세스를 동시에 실행되는 것처럼 보이게 한다. 
    + 프로세스의 전환은 운영체제 커널(kernel)에 의해 관리된다.
        + 커널 : 메모리에 상주하는 운영체제 코드의 일부분. 프로세스로 분류되지 않는다.
    + 운영체제의 스케줄링을 통해 한 프로세스는 자신이 시스템의 자원을 독점하고 있는 것처럼 사용할 수 있다.
    + 운영체제는 프로세스의 상태 정보(context)를 추적하고 관리한다.

아래 그림은 문맥 전환을 도식화한 것이다.

![context_switching](/assets/images/csapp/context_switching.png)

+ 쓰레드(thread) : 프로세스를 구성하는 실행 유닛이다.
    + 프로세스가 프로그램의 단위라면, 쓰레드는 각자의 작업을 가진 실행 유닛이다.
        > 프로세스가 갈비찜 만들기라면 쓰레드는 당근 썰기, 고기 손질하기 등으로 비유될 수 있다.
    + 프로세스는 하나 이상의 쓰레드로 이루어진다.
    + 쓰레드를 이용하면 한 프로세스 내의 데이터 공유가 쉽다. 
        + 프로세스 간 데이터 공유는 운영체제를 통해 이루어져야 한다.

+ 가상 메모리(virtual memory) : 프로세스가 메인 메모리를 독점적으로 사용하는 것처럼 느끼게 하는 추상화.
    + 각 프로세스는 가상주소 공간이라는 균일한 메모리의 모습을 가지게 된다. 가상주소 공간은 몇 개의 영역으로 구성되어 있다.

+ 가상주소공간(virtual address space)

    아래 그림은 리눅스 프로그램의 가상주소 공간을 나타낸 것이다.

    ![ㅣinux_virtual_address_space](/assets/images/csapp/linux_virtual_address_space.png)

    + 프로그램 코드/데이터 
    + 힙(heap) : malloc(), free() 함수의 호출로 인해 런타임에 크기가 유동적인 메모리 공간이다.
    + 공유 라이브러리(shared library) : 공유이브러리의 코드/데이터가 저장되는 공간이다.
    + 스택(stack) : 컴파일러가 함수 호출을 위해 활용하는 공간이다.
    + 커널 가상메모리 : 커널을 위해 예약된 공간으로, 응용 프로그램은 이 영역에 접근할 수 없다. 여기에 정의된 함수를 사용하기 위해서는 커널을 호출해야 한다.

+ 파일 : 연속된 바이트들이다. 유닉스 시스템에서는 입출력 장치를 파일로 모델링한다. 

---

## Amdahl의 법칙

시스템의 성능 개선의 효율성을 계산하는 방법이다.

어떤 응용을 실행하는 데 걸리는 시간이 Told일 때,  
이 시스템의 어떤 부분이 걸리는 시간의 a만큼의 비중을 차지한다고 하면  
해당 부분을 k배 개선했을 때 걸리는 시간 Tnew는 다음과 같이 계산될 수 있다.

![amdahls_law](/assets/images/csapp/amdahls_law.png)

---

## 동시성과 병렬성

+ 동시성(concurrency) : 다수의 일을 한번에
+ 병렬성(parallelism) : 동시성을 이용해 시스템의 속도 향상

1. 일의 단위 분리(프로세스/쓰레드)
1. CPU 코어의 수 증가
1. 동시에 여러 작업 수행 가능
1. 결과적으로 시스템의 성능 향상됨.

최근에는 훨씬 낮은 수준에서의 추상화를 통해 인스트럭션 수준에서의 병렬성을 기대할 수 있다.  

결과적으로 시스템의 성능이 좋아졌다. 뭐 이런 내용이다.

---

### 추상화

추상화(abstraction)란 복잡한 구현에 대한 API를 제공하는 것이다.  
사용자가 구현을 이해해거나 신경쓰지 않아도 되게 한다.  
전산학에서는 중요한 개념이라고 한다.

---
1장에서 공부한 내용을 간단하게 요약해 보았다.
